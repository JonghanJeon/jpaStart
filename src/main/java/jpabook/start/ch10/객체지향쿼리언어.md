JPA는 복잡한 검색 조건을 사용해서 엔티티 객체를 조회할 수 있는 다양한 쿼리 기술을 지원한다.<br/>
JPQL은 가장 중요한 객체지향 쿼리 언어다.<br/>
Criteira 나 QueryDSL은 결국 JPQL을 편리하게 사용하도록 도와주는 기술이므로 JPA를 다루는 개발자라면 JPQL을 필수로 학습해야 한다.<br/>

## 객체지향 쿼리 소개
ORM을 사용하면 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 개발하므로 검색도 테이블이 아닌 엔티티 **객체를 대상으로** 하는 방법이 필요하다.<br/>
JPQL은 이런 문제를 해결하기 위해 만들어졌는데 다음과 같은 특징이 있다.
- 테이블이 아닌 **객체를 대상으로 검색하는 객체지향 쿼리**다.
- SQL을 추상화해서 **특정 데이터베이스 SQL에 의존하지 않는다.**

JPQL을 사용하면 JPQ는 JPQL을 분석한 다음 적절한 SQL을 만들어 데이터베이스를 조회한다. <br/>
그리고 조회한 결과로 엔티티 객체를 생성해서 반환한다.<br/>
JPQL을 한마디로 정의하면 **객체지향 SQL**이다.<br/>
JPQ는 JPQL뿐만 아니라 다양한 검색 방법을 제공한다.
- JPQL; Java Persistence Query Language
- Criteria 쿼리; JPQL을 편하게 작성하도록 도와주는 API, 빌더 클래스 모음
- 네이티브 SQL; JPA에서 JPQL대신 직접 SQL을 사용할 수 있다.

다음은 JPA가 공식 지원하는 기능은 아니지만 알아둘 가치가 있다.
- QueryDSL; Criteria 쿼리처럼 JPQL을 편하게 작성하도록 도와주는 빌더 클래스 모음, 비표준 오픈소스 프레임워크다.
- JDBC 직접 사용, MyBatis 같은 SQL 매퍼 프레임워크 사용; 필요하면 JDBC를 직접 사용할 수 있다.

### JPQL 소개
**JPQL은 엔티티 객체를 조회하는 객체지향 쿼리다.** 문법은 SQL과 비슷하다.<br/>
**JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다.** 그리고 데이터베이스 방언(Dialect)만 변경하면 JPQL을 수정하지 않아도 자연스럽게 데이터베이스를 변경할 수 있다.<br/>
**JPQL은 SQL보다 간결하다.** 

### Creteria 쿼리 소개
**Criteria 는 JPQL을 생성하는 빌더 클래스**이다.<br/>
**qeury.select(m).where(...)처럼 프로그래밍 코드로 JPQL을 작성**할 수 있다는 점이다.  
- 예를들어 **JPQL 에서 select m from Membeee m 처럼 오타가 있다고 가정**해보자. 컴파일은 성공하고 애플리케이션을 서버에 배포할 수 있지만, 해당 쿼리가 실행되는 **런타임 시점에 오류가 발생**한다는 점이다.  
- **반면 Criteria**는 문자가 아닌 **코드로 JPQL을 작성**한다. 따라서 **컴파일 시점에 오류를 발견**할 수 있다.
### Creteria 장점
1. 컴파일 시점에 오류를 발견할 수 있다.
2. IDE를 사용하면 코드 자동완성을 지원한다.
3. 동적 쿼리를 작성하기 편하다.

간단하게 `select m from Member as m where m.username = 'kim'` JPQL을 Criteria 로 작성해보면  
```
//Criteria 사용 준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

//루트 클래스(조회를 시작할 클래스)
Root<Member> m = query.from(Member.class);

//쿼리 생성
CriteriaQuery<Member> cq =
        query.select(m).where(cb.equal(m.get("username"), "kim"));
List<Member> resultList = em.createQuery(cq).getResultList();
```
위와 같이 작성할 수 있다.  
### QueryDSL 소개
QueryDSL 도 Creteria처럼 JPQL 빌더 역할을 한다. QueryDSL의 장점은 **코드 기반이면서 단순하고 사용하기 쉽다.**  
그리고 **작성한 코드도 JPQL과 비슷**해서 한눈에 들어온다.  

## JPQL
### JPQL의 특징
- JPQL은 객체지향 쿼리 언어다. 따라서 테이블을 대상으로 쿼리하는 것이 아니라 엔티티 객체를 대상으로 쿼리한다.
- JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.
- JPQL은 결국 SQL로 변환된다.
### 예재로 사용할 도메인 모델
![img.png](images/domainModel.png)
### 기본 문법과 쿼리 API
JPQL도 SQL과 비슷하게 SELECT, UPDATE, DELETE 문을 사용할 수 있다.  
참고로 엔티티를 저장할 때는 EntityManager.persist() 메소드를 사용하면 되므로 **INSERT문은 없다**.  
#### SELECT 문
- 대소문자 구분
  - **엔티티와 속성은 대소문자를 구분**한다.
  - 예를들어 Member, username 은 대소문자를 구분한다.
  - 반면, SELECT, FROM, AS 같은 **JPQL키워드는 대소문자를 구분하지 않는다.**
- 엔티티 이름
  - JPQL에서 사용한 Member 는 클래스 명이 아니라 엔티티 명이다.
  - 엔티티 명은 `@Entity(name = "XXX")`로 지정할 수 있다.
  - **엔티티 명을 지정하지 않으면 클래스 명을 기본값으로 사용**한다.
  - **기본값인 클래스 명을 엔티티 명으로 사용하는 것을 추천**한다.
- 별칭은 필수
  - Member AS m 을 보면 Member 에 m 이라는 별칭을 주었다.
  - **JPQL은 별칭을 필수로 사용**해야 한다!!
  - 따라서 다음 코드처럼 별칭 없이 작성하면 잘못된 문법이라는 오류가 발생한다.
  - `SELECT username FROM Member m`
#### TypeQuery, Query
**작성한 JPQL을 실행하려면 쿼리 객체를 만들어야 한다.**  
쿼리 객체는 TypeQuery와 Query가 있는데 **반환할 타입을 명확하게 지정할 수 있으면 TypeQuery 객체를 사용하고, 명확하게 지정할 수 없으면 Query 객체를 사용**하면 된다.  
```
TypeQuery<Member> query = 
    em.createQuery("SELECT m FROM Member m", Member.class);
```
**em.createQuery()의 두 번째 파라미터에 반환할 타입을 지정하면 TypeQuery를 반환하고 지정하지 않으면 Query를 반환**한다.  
```
Query query = 
    em.createQuery("SELECT m.username, m.age from Member m");
```
위의 경우 조회 대상이 String 타입인 회원 이름과 Integer 타입인 나이이므로 조회 대상 타입이 명확하지 않다.  
이처럼 **SELECT 절에서 여러 엔티티나 컬럼을 선택할 때**는 반환할 타입이 명확하지 않으므로 **Query 객체를 사용**해야 한다.  
**Query 객체는 SELECT 절의 조회 대상이 예제처럼 둘 이상이면 Object[ ]를 반환**하고, SELECT절의 **조회 대상이 하나면 Object를 반환**한다.  
예를 들어 `SELECT m.username from Member m` 이면 결과를 Object 로 반환하고, `SELECT m.username, m.age from Member m`이면 Object[ ]를 반환한다.  
두 코드를 비교해보면 타입을 반환할 필요가 없는 TypeQuery를 사용하는 것이 더 편리한 것을 알 수 있다.  

#### 결과 조회
다음 메소드들을 호출하면 실제 쿼리를 실행해서 데이터베이스를 조회한다.  
- query.getResultList( ): 결과를 예제로 반환한다. 만약 결과가 없으면 빈 컬렉션을 반환한다.
- query.getSingleResult(): 결과가 정확히 하나일 때 사용한다.
  - **결과가 없으면 NoResultException 예외가 발생**한다.
  - **결과가 1개보다 많으면 NoUniqueResultException 예외가 발생**한다.

### 파라미터 바인딩 p358