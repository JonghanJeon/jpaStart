JPA는 복잡한 검색 조건을 사용해서 엔티티 객체를 조회할 수 있는 다양한 쿼리 기술을 지원한다.<br/>
JPQL은 가장 중요한 객체지향 쿼리 언어다.<br/>
Criteira 나 QueryDSL은 결국 JPQL을 편리하게 사용하도록 도와주는 기술이므로 JPA를 다루는 개발자라면 JPQL을 필수로 학습해야 한다.<br/>

## 객체지향 쿼리 소개
ORM을 사용하면 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 개발하므로 검색도 테이블이 아닌 엔티티 **객체를 대상으로** 하는 방법이 필요하다.<br/>
JPQL은 이런 문제를 해결하기 위해 만들어졌는데 다음과 같은 특징이 있다.
- 테이블이 아닌 **객체를 대상으로 검색하는 객체지향 쿼리**다.
- SQL을 추상화해서 **특정 데이터베이스 SQL에 의존하지 않는다.**

JPQL을 사용하면 JPQ는 JPQL을 분석한 다음 적절한 SQL을 만들어 데이터베이스를 조회한다. <br/>
그리고 조회한 결과로 엔티티 객체를 생성해서 반환한다.<br/>
JPQL을 한마디로 정의하면 **객체지향 SQL**이다.<br/>
JPQ는 JPQL뿐만 아니라 다양한 검색 방법을 제공한다.
- JPQL; Java Persistence Query Language
- Criteria 쿼리; JPQL을 편하게 작성하도록 도와주는 API, 빌더 클래스 모음
- 네이티브 SQL; JPA에서 JPQL대신 직접 SQL을 사용할 수 있다.

다음은 JPA가 공식 지원하는 기능은 아니지만 알아둘 가치가 있다.
- QueryDSL; Criteria 쿼리처럼 JPQL을 편하게 작성하도록 도와주는 빌더 클래스 모음, 비표준 오픈소스 프레임워크다.
- JDBC 직접 사용, MyBatis 같은 SQL 매퍼 프레임워크 사용; 필요하면 JDBC를 직접 사용할 수 있다.

### JPQL 소개
**JPQL은 엔티티 객체를 조회하는 객체지향 쿼리다.** 문법은 SQL과 비슷하다.<br/>
**JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다.** 그리고 데이터베이스 방언(Dialect)만 변경하면 JPQL을 수정하지 않아도 자연스럽게 데이터베이스를 변경할 수 있다.<br/>
**JPQL은 SQL보다 간결하다.** 

### Creteria 쿼리 소개
**Criteria 는 JPQL을 생성하는 빌더 클래스**이다.<br/>
**qeury.select(m).where(...)처럼 프로그래밍 코드로 JPQL을 작성**할 수 있다는 점이다.  
- 예를들어 **JPQL 에서 select m from Membeee m 처럼 오타가 있다고 가정**해보자. 컴파일은 성공하고 애플리케이션을 서버에 배포할 수 있지만, 해당 쿼리가 실행되는 **런타임 시점에 오류가 발생**한다는 점이다.  
- **반면 Criteria**는 문자가 아닌 **코드로 JPQL을 작성**한다. 따라서 **컴파일 시점에 오류를 발견**할 수 있다.
### Creteria 장점
1. 컴파일 시점에 오류를 발견할 수 있다.
2. IDE를 사용하면 코드 자동완성을 지원한다.
3. 동적 쿼리를 작성하기 편하다.

간단하게 `select m from Member as m where m.username = 'kim'` JPQL을 Criteria 로 작성해보면  
```
//Criteria 사용 준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

//루트 클래스(조회를 시작할 클래스)
Root<Member> m = query.from(Member.class);

//쿼리 생성
CriteriaQuery<Member> cq =
        query.select(m).where(cb.equal(m.get("username"), "kim"));
List<Member> resultList = em.createQuery(cq).getResultList();
```
위와 같이 작성할 수 있다.  
### QueryDSL 소개
QueryDSL 도 Creteria처럼 JPQL 빌더 역할을 한다. QueryDSL의 장점은 **코드 기반이면서 단순하고 사용하기 쉽다.**  
그리고 **작성한 코드도 JPQL과 비슷**해서 한눈에 들어온다.  

## JPQL
### JPQL의 특징
- JPQL은 객체지향 쿼리 언어다. 따라서 테이블을 대상으로 쿼리하는 것이 아니라 엔티티 객체를 대상으로 쿼리한다.
- JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.
- JPQL은 결국 SQL로 변환된다.
### 예재로 사용할 도메인 모델
![img.png](images/domainModel.png)
### 기본 문법과 쿼리 API
JPQL도 SQL과 비슷하게 SELECT, UPDATE, DELETE 문을 사용할 수 있다.  
참고로 엔티티를 저장할 때는 EntityManager.persist() 메소드를 사용하면 되므로 **INSERT문은 없다**.  
#### SELECT 문
- 대소문자 구분
  - **엔티티와 속성은 대소문자를 구분**한다.
  - 예를들어 Member, username 은 대소문자를 구분한다.
  - 반면, SELECT, FROM, AS 같은 **JPQL키워드는 대소문자를 구분하지 않는다.**
- 엔티티 이름
  - JPQL에서 사용한 Member 는 클래스 명이 아니라 엔티티 명이다.
  - 엔티티 명은 `@Entity(name = "XXX")`로 지정할 수 있다.
  - **엔티티 명을 지정하지 않으면 클래스 명을 기본값으로 사용**한다.
  - **기본값인 클래스 명을 엔티티 명으로 사용하는 것을 추천**한다.
- 별칭은 필수
  - Member AS m 을 보면 Member 에 m 이라는 별칭을 주었다.
  - **JPQL은 별칭을 필수로 사용**해야 한다!!
  - 따라서 다음 코드처럼 별칭 없이 작성하면 잘못된 문법이라는 오류가 발생한다.
  - `SELECT username FROM Member m`
#### TypeQuery, Query
**작성한 JPQL을 실행하려면 쿼리 객체를 만들어야 한다.**  
쿼리 객체는 TypeQuery와 Query가 있는데 **반환할 타입을 명확하게 지정할 수 있으면 TypeQuery 객체를 사용하고, 명확하게 지정할 수 없으면 Query 객체를 사용**하면 된다.  
```
TypeQuery<Member> query = 
    em.createQuery("SELECT m FROM Member m", Member.class);
```
**em.createQuery()의 두 번째 파라미터에 반환할 타입을 지정하면 TypeQuery를 반환하고 지정하지 않으면 Query를 반환**한다.  
```
Query query = 
    em.createQuery("SELECT m.username, m.age from Member m");
```
위의 경우 조회 대상이 String 타입인 회원 이름과 Integer 타입인 나이이므로 조회 대상 타입이 명확하지 않다.  
이처럼 **SELECT 절에서 여러 엔티티나 컬럼을 선택할 때**는 반환할 타입이 명확하지 않으므로 **Query 객체를 사용**해야 한다.  
**Query 객체는 SELECT 절의 조회 대상이 예제처럼 둘 이상이면 Object[ ]를 반환**하고, SELECT절의 **조회 대상이 하나면 Object를 반환**한다.  
예를 들어 `SELECT m.username from Member m` 이면 결과를 Object 로 반환하고, `SELECT m.username, m.age from Member m`이면 Object[ ]를 반환한다.  
두 코드를 비교해보면 타입을 반환할 필요가 없는 TypeQuery를 사용하는 것이 더 편리한 것을 알 수 있다.  

#### 결과 조회
다음 메소드들을 호출하면 실제 쿼리를 실행해서 데이터베이스를 조회한다.  
- query.getResultList( ): 결과를 예제로 반환한다. 만약 결과가 없으면 빈 컬렉션을 반환한다.
- query.getSingleResult(): 결과가 정확히 하나일 때 사용한다.
  - **결과가 없으면 NoResultException 예외가 발생**한다.
  - **결과가 1개보다 많으면 NoUniqueResultException 예외가 발생**한다.

### 파라미터 바인딩
JDBC는 위치 기준 파라미터 바인딩만 지원하지만, **JPQL은 이름 기준 파라미터 바인딩도 지원**한다.  
- 이름 기준 파라미터
  - 파라미터를 이름으로 구분하는 방법이다.
  - 이름 기준 파라미터는 앞에 :를 사용한다.
  - ```
    String usernameParam = "User1";
    
    TypedQuery<Member> query =
      em.createQuery("SELECT m FROM Member m WHERE m.username = :username", Member.class);
    
    query.setParameter("username", usernameParam);
    List<Member> resultList = query.getResultList();
    ```
  - 참고로 **JPQL API는 대부분 메소드 체인 방식으로 설계**되어 있어서 다음과 같이 연속해서 작성할 수 있다.
  - ```
    List<Member> members = 
      em.createQuery("SELECT m From Member m WHERE m.username = :username", Member.class)
        .setParameter("username", usernameParam)
        .getResultList();
    ```
  - 위치 기준 파라미터 방식보다는 **이름 기준 파라미터 바인딩 방식을 사용하는 것이 더 명확**하다.

### 프로젝션
**SELECT 절에 조회할 대상을 지정하는 것을 프로젝션** 이라 하고 `SELECT (프로젝션 대상) FROM` 으로 대상을 선택한다.  
프로젝션 대상은 엔티티, 엠비디드 타입, 스칼라 타입이 있다.  
- 엔티티 프로젝션
  - ```
    SELECT m FROM Member m //회원
    SELECT m.team FROM Member m //팀
    ```
  - 원하는 객체를 바로 조회한 것인데 컬럼을 하나하나 나열해서 조회해야 하는 SQL과는 차이가 있다.
  - 이렇게 **조회한 엔티티는 영속성 컨텍스트에서 관리**된다.
- 임베디드 타입 프로젝션
  - JPQL에서 이베디드 타입은 엔티티와 거의 비슷하게 사용된다.
  - 임베디드 타입은 조회의 시작점이 될 수 없다는 제약이 있다.
  - 다음은 임베디드 타입인 Address 를 조회의 시작점으로 사용해서 잘못된 쿼리이다.
  - ```
    String query = "SELECT a FROM Address a";
    ```
  - 다음 코드에서 Order 엔티티가 시작점이다.
  - ```
    String query = "SELECT o.address FROM Order o";
    List<Address> addresses = em.createQuery(query, Address.class)
                                .getResultList();
    ```  
  - **임베디드 타입은** 엔티티 타입이 아닌 **값 타입**이다.
  - **따라서 직접 조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않는다.**

> **임베디드 타입이란?**
>> 새로운 값 타입을 직접 정의해서 사용할 수 있는데, JPA에서는 이것을 임베디드 타입(embedded type)이라 합니다.  
>> 중요한 것은 직접 정의한 임베디드 타입도 `int`, `String` 처럼 값 타입이라는 것입니다.  
> ```
> //임베디드 타입을 사용하지 않았을 때
> @Entity
> public class Member {
> 
>   @Id @Generatedvalue
>   private Long id;
>   private String name;
> 
>   //근무 기간
>   @Temporal(TemporalType.DATE)
>   Date startDate;
>   @Temporal(TemporalType.DATE)
>   Date endDate;
> 
>   //집 주소 표현
>   private String city;
>   private String street;
>   private String zipcode;
> }
> ```
> ```
> //임베디드 타입 사용
> @Entity
> public class Member {
>
>   @Id @GeneratedVAlue
>   private Long id;
>   private String name;
>
>   @Embedded
>   private Period workPeriod;	// 근무 기간
>
>   @Embedded
>   private Address homeAddress;	// 집 주소
> }
> 
> //기간 임베디드 타입
> @Embeddable
> public class Peroid {
>
>   @Temporal(TemporalType.DATE)
>   Date startDate;
>   @Temporal(TemporalType/Date)
>   Date endDate;
>   // ...
>
>   public boolean isWork (Date date) {
>     // .. 값 타입을 위한 메서드를 정의할 수 있다
>   }
> }
> 
> //주소 임베디드 타입
> @Embeddable
> public class Address {
>
>     @Column(name="city") // 매핑할 컬럼 정의 가능
>     private String city;
>     private String street;
>     private String zipcode;
>     // ...
> }
> ```  

- 스칼라 타입 프로젝션
  - 숫자, 문자, 날짜와 같은 **기본 데이터 타입들을 스칼라 타입**이라 한다.
  - 예를 들어 전체 회원의 이름을 조회하려면 다음처럼 쿼리하면 된다.
  - ```
    List<String> usernames = 
      em.createQuert("SELECT username FROM Member m", String.class)
        .getResultList();
    ```
  - 다음과 같은 통계 쿼리도 주로 스칼라 타입으로 조회한다. (통계 쿼리용 함수들은 뒤에서 설명)
    - ```
      Double orderAmountAvg = 
        em.createQuert("SELECT AVG(o.orderAmount) FROM Order o", Double.class)
          .getSingleResult();
      ```  
- 여러 값 조회
  - 엔티티를 대상으로 조회하면 편리하겠지만, 꼭 필요한 데이터들만 선택해서 조회해야 할 때도 있다.
  - 프로젝션에 여러 값을 선택하면 TypeQuery를 사용할 수 없고 대신에 Query를 사용해야 한다.
  - ```
    Query query = 
      em.createQuery("SELECT m.username, m.age FROM Member m");
    List<Object[]> resultList = query.getResultList();
    
    Iterator iterator = resultList.iterator();
    while (iterator.hasNext()) {
      Object[] row = (Object[]) iterator.next();
      String username = (String) row[0];
      Integer age = (Integer) row[1];
    }
    ```
  - ```
    List<Object[]> resultList = 
      em.createQuery("SELECT m.username, m.age FROM Member m")
        .getResultList();
    
    for (Object[] row : resultList) {
      String username = (String) row[0];
      Integer age = (Integer) row[1];
    }
    ```  
  - 스칼라 타입 뿐만 아니라 엔티티 타입도 여러 값을 함께 조회할 수 있다.
  - ```
    List<Object[]> resultList = 
      em.createQuery("SELECT o.member, o.product, o.orderAmount FROM Order o")
        .getResultList();
    
    for (Object[] row : resultList) {
      Member memeber = (Member) row[0];       //엔티티
      Product product = (Product) row[1];     //엔티티
      Integer orderAmount = (Integer) row[2]; //스칼라
    }
    ```  
  - 물론 이 때 조회한 엔티티는 영속성 컨텍스트에서 관리된다.
- NEW 명령어
  - 실제 애플리케이션 개발시에는 Object[] 를 직접 사용하지 않고, UserDTO 처럼 의미 있는 객체로 변환해서 사용할 것이다.
  - ```
    List<Object[]> resultList = 
      em.createQuery("SELECT m.username, m.age FROM Member m")
        .getResultList();
    
    //객체 변환 작업
    List<UserDTO> userDTOs = new ArrayList<UserDTO>();
    for (Object[] row : resultList) {
      UserDTO userDTO = new UserDTO((String) row[0], (Integer) row[1]);
      userDTOs.add(userDTO);
    }
    ```
  - 이런 객체 변환 작업은 지루하다. NEW 명령어를 사용해보자
  - ```
    TypedQuery<UserDTO> query =
      em.createQuery("SELECT new jpabook.jpql.UserDTO(m.username, m.age)
      FROM Member m", UserDTO.class);
    
    List<UserDTO> resultList = query.getResultList();
    ```  
  - **SELECT 다음에 NEW 명령어를 사용하면 반환받을 클래스를 지정**할 수 있는데, 이 **클래스의 생성자에 JPQL 조회 결과를 넘겨줄 수 있다.**
  - 그리고 **NEW 명령어를 사용한 클래스로 TypeQuery를 사용할 수 있어** 지루한 **객체 변환 작업을 줄일 수 있다.**
  - 주의점 2가지
    1. **패키지 명을 포함한 전체 클래스 명을 입력**해야한다.
    2. **순서와 타입이 일치하는 생성자가 필요**하다.

### 페이징 API
페이징 처리용 SQL을 작성하는 일은 지루하고 반복적이다.  
더 큰 문제는 **데이터베이스마다 페이징을 처리하는 SQL 문법이 다르다는 점**이다.  

JPA는 페이징을 다음 두 API로 추상화 했다.
- setFirstResult(int startPosition) : 조회 시작 위치(0부터 시작)
- setMaxResults(int maxResult) : 조회할 데이터 수
```
TypedQuery<Member> query = 
  em.createQuery("SELECT m FROM Member m ORDER BY m.username DESC", Member.class);
  
query.setFirstResult(10);
query.setMaxResults(20);
query.getResultList();
```
위 코드를 분석하면 FirstResult의 시작은 0이므로 11번째부터 시작해서 총 20건의 데이터를 조회한다.  
따라서 11 ~ 30번 데이터를 조회한다.  
데이터베이스마다 SQL이 다른 것은 물론이고 오라클과 SQLServer는 페이징 쿼리를 따로 공부해야 SQL을 작성할 수 있을 정도로 복잡하다.  

#### 집합과 정렬
**집합은 집합함수와 함께 통계 정보를 구할 때 사용**한다.  
- 집합 함수
  ![img.png](images/집합함수.png)
- 집합 함수 사용 시 참고사항
  - **NULL 값은 무시하므로 통계에 잡히지 않는다.** (DISTINCT 가 정의되어 있어도 무시된다.)
  - 만약 값이 없는데 SUM, AVG, MAX, MIN 함수를 사용하면 NULL 값이 된다. 단 COUNT 는 0이 된다.
  - DISTINCT를 집합 함수 안에 사용해서 중복된 값을 제거하고 나서 집합을 구할 수 있다.
#### GROUP BY, HAVING
`GROUP BY`는 통계 데이터를 구할 때 **특정 그룹끼리 묶어준다.**  
다음은 팀 이름을 기준으로 그룹별로 묶어서 통계 데이터를 구한다.  
```
select t.name, COUNT(m.age), SUM(m.age), AVG(m.age), MAX(m.age), MIN(m.age)
from Member m LEFT JOIN m.team t
GROUP BY t.name
```
`HAVING`은 `GROUP BY`와 함께 사용하는데 **GROUP BY로 그룹화한 통계 데이터를 기준으로 필터링** 한다.  
다음 코드는 방금 구한 그룹별 통계 데이터 중 평균 나이가 10살 이상인 그룹을 조회한다.  
```
select t.name, COUNT(m.age), SUM(m.age), AVG(m.age), MAX(m.age), MIN(m.age)
from Member m LEFT JOIN m.team t
GROUP BY t.name 
HAVING AVG(m.age) >= 10
```
#### 정렬(ORDER BY)
`ORDER BY`는 **결과를 정렬**할 때 사용한다.  
다음은 나이를 기준으로 내림차순으로 정렬하고 나이가 같으면 이름을 기준으로 오름차순으로 정렬한다.  
```
select m from Member m ORDER BY m.age DESC, m.name ASC;
```
#### JPQL 조인
JPQL도 조인을 지원하는데 SQL 조인과 기능은 같고 문법만 약간 다르다.  
- 내부 조인
  - 내부 조인은 `INNER JOIN`을 사용한다. **참고로 INNER 는 생략할 수 있다.**  
  ```
  String teamName = "팀A";
  String query = "SELECT m FROM Member m INNER JOIN m.team t "
                  + "WHERE t.name = :teamName";
  
  List<Member> members = em.createQuery(query, Member.class)
                            .setParameter("teamName", teamName)
                            .getResultList();
  ```
  - 생성된 내부 조인 SQL은 다음과 같다.
  ```
  SELECT
    M.ID AS ID,
    M.AGE AS AGE,
    M.TEAM_ID AS TEAM_ID,
    M.NAME AS NAME
  FROM
    MEMBER M INNER JOIN TEAM T ON M.TEAM_ID = T.ID
  WHERE
    T.NAME=?
  ```
  - JPQL조인의 가장 큰 특징은 연관 필드를 사용한다는 것이다.  
  - 여기서 m.team이 연관 필드인데 **연관 필드는 다른 엔티티와 연관관계를 가지기 위해 사용하는 필드**를 말한다.
  - 혹시라도 JPQL 조인을 SQL 조인처럼 사용하면 문법 오류가 발생한다.
  ```
  FROM Member m JOIN Team t // 잘못된 JPQL 조인, 오류!!
  ```
  - 서로 다른 타입의 두 엔티티를 조회한다면 TypeQuery를 사용할 수 없다.
  ```
  SELECT m, t FROM Member m JOIN m.team t
  ```
  ```
  List<Object[]> result = em.createQuery(query).getResultList();
  
  for (Object [] row : result) {
    Member member = (Member) row[0];
    Team team = (Team) row[1];
  }
  ```
- 외부 조인
  - 외부 조인은 다음과 같이 사용한다.
  ```
  SELECT m
  FROM Member m LEFT {OUTER} JOIN m.team t
  ```
  - 외부 조인은 기능상 SQL의 외부 조인과 같다.  
  - **OUTER는 생략 가능해서 보통 LEFT JOIN 으로 사용한다.**
  - 다음과 같은 SQL이 실행된다.
  ```
  SELECT
    M.ID AS ID,
    M.AGE AS AGE,
    M.TEAM_ID AS TEAM_ID,
    M.NAME AS NAME
  FROM
    MEMBER M LEFT OUTER JOIN TEAM T ON M.TEAM_ID=T.ID
  WHERE
    T.NAME=?
  ```
- 컬렉션 조인
  - 일대다 관계나 다대다 관계처럼 **컬렉션을 사용하는 곳에 조인하는 것을 컬렉션 조인이라 한다.**
    - [회원 -> 팀]으로의 조인은 다대일 조인이면서 단일 값 연관 필드(m.team)을 사용한다.
    - [팀 -> 회원]으로의 조인은 일대다 조인이면서 컬렉션 값 연관 필드(m.member)를 사용한다.
  ```
  SELECT t, m FROM Team t LEFT JOIN t.members m
  ```
  - 여기서 t LEFT JOIN t.members 는 팀과 팀이 보유한 회원목록을 **컬렉션 값 연관 필드로 외부 조인**했다.
  > 참고: 컬렉션 조인시 JOIN 대신에 IN을 사용할 수 있는데, 기능상 JOIN 과 같지만 컬렉션일 때만 사용할 수 있다. 과거의 유물이고 특별한 장점이 없으므로 그냥 JOIN 명령어를 사용하자.
- 세타 조인
  - WHERE 절을 사용해서 세타 조인을 할 수 있다.
  - 참고로 **세타 조인은 내부 조인만 지원**한다.
  - **세타 조인을 사용하면 전혀 관계없는 엔티티도 조인할 수 있다.**
  ```
  //회원 이름이 팀 이름과 똑같은 사람 수를 구하는 예
  //JPQL
  select count(m) from Member m, Team t
  where m.username = t.name
  
  //SQL
  SELECT COUNT(M.ID)
  FROM
    MEMBER M CROSS JOIN TEAM T
  WHERE
    M.USERNAME=T.NAME
  ```
- JOIN ON 절(JPQ 2.1)
  - JPA 2.1부터 조인할 때 ON 절을 지원한다.
  - ON 절을 사용하면 **조인 대상을 필터링 하고 조인**할 수 있다.
  - 참고로 **내부 조인의 ON 절은 WHERE 절을 사용할 때와 결과가 같으므로 보통 ON 절은 외부 조인에서만 사용**한다.
  ```
  //JPQL
  select m, t 
  from Member m left join m.team t on t.name = 'A'
  
  //SQL
  SELECT m.*, t.*
  FROM
    Member m LEFT JOIN Team t ON m.TEAM_ID=t.id and t.name='A'
  ```
  - SQL 결과를 보면 and t.name='A'로 **조인 시점에 조인 대상을 필터링**한다.
