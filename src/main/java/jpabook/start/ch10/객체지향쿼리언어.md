JPA는 복잡한 검색 조건을 사용해서 엔티티 객체를 조회할 수 있는 다양한 쿼리 기술을 지원한다.<br/>
JPQL은 가장 중요한 객체지향 쿼리 언어다.<br/>
Criteira 나 QueryDSL은 결국 JPQL을 편리하게 사용하도록 도와주는 기술이므로 JPA를 다루는 개발자라면 JPQL을 필수로 학습해야 한다.<br/>

## 객체지향 쿼리 소개
ORM을 사용하면 데이터베이스 테이블이 아닌 엔티티 객체를 대상으로 개발하므로 검색도 테이블이 아닌 엔티티 **객체를 대상으로** 하는 방법이 필요하다.<br/>
JPQL은 이런 문제를 해결하기 위해 만들어졌는데 다음과 같은 특징이 있다.
- 테이블이 아닌 **객체를 대상으로 검색하는 객체지향 쿼리**다.
- SQL을 추상화해서 **특정 데이터베이스 SQL에 의존하지 않는다.**

JPQL을 사용하면 JPQ는 JPQL을 분석한 다음 적절한 SQL을 만들어 데이터베이스를 조회한다. <br/>
그리고 조회한 결과로 엔티티 객체를 생성해서 반환한다.<br/>
JPQL을 한마디로 정의하면 **객체지향 SQL**이다.<br/>
JPQ는 JPQL뿐만 아니라 다양한 검색 방법을 제공한다.
- JPQL; Java Persistence Query Language
- Criteria 쿼리; JPQL을 편하게 작성하도록 도와주는 API, 빌더 클래스 모음
- 네이티브 SQL; JPA에서 JPQL대신 직접 SQL을 사용할 수 있다.

다음은 JPA가 공식 지원하는 기능은 아니지만 알아둘 가치가 있다.
- QueryDSL; Criteria 쿼리처럼 JPQL을 편하게 작성하도록 도와주는 빌더 클래스 모음, 비표준 오픈소스 프레임워크다.
- JDBC 직접 사용, MyBatis 같은 SQL 매퍼 프레임워크 사용; 필요하면 JDBC를 직접 사용할 수 있다.

### JPQL 소개
**JPQL은 엔티티 객체를 조회하는 객체지향 쿼리다.** 문법은 SQL과 비슷하다.<br/>
**JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다.** 그리고 데이터베이스 방언(Dialect)만 변경하면 JPQL을 수정하지 않아도 자연스럽게 데이터베이스를 변경할 수 있다.<br/>
**JPQL은 SQL보다 간결하다.** 

### Creteria 쿼리 소개
**Criteria 는 JPQL을 생성하는 빌더 클래스**이다.<br/>
**qeury.select(m).where(...)처럼 프로그래밍 코드로 JPQL을 작성**할 수 있다는 점이다.  
- 예를들어 **JPQL 에서 select m from Membeee m 처럼 오타가 있다고 가정**해보자. 컴파일은 성공하고 애플리케이션을 서버에 배포할 수 있지만, 해당 쿼리가 실행되는 **런타임 시점에 오류가 발생**한다는 점이다.  
- **반면 Criteria**는 문자가 아닌 **코드로 JPQL을 작성**한다. 따라서 **컴파일 시점에 오류를 발견**할 수 있다.
### Creteria 장점
1. 컴파일 시점에 오류를 발견할 수 있다.
2. IDE를 사용하면 코드 자동완성을 지원한다.
3. 동적 쿼리를 작성하기 편하다.

간단하게 `select m from Member as m where m.username = 'kim'` JPQL을 Criteria 로 작성해보면  
```
//Criteria 사용 준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

//루트 클래스(조회를 시작할 클래스)
Root<Member> m = query.from(Member.class);

//쿼리 생성
CriteriaQuery<Member> cq =
        query.select(m).where(cb.equal(m.get("username"), "kim"));
List<Member> resultList = em.createQuery(cq).getResultList();
```
위와 같이 작성할 수 있다.  
### QueryDSL 소개
QueryDSL 도 Creteria처럼 JPQL 빌더 역할을 한다. QueryDSL의 장점은 **코드 기반이면서 단순하고 사용하기 쉽다.**  
그리고 **작성한 코드도 JPQL과 비슷**해서 한눈에 들어온다.  

## JPQL
### JPQL의 특징
- JPQL은 객체지향 쿼리 언어다. 따라서 테이블을 대상으로 쿼리하는 것이 아니라 엔티티 객체를 대상으로 쿼리한다.
- JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.
- JPQL은 결국 SQL로 변환된다.
### 예재로 사용할 도메인 모델
![img.png](images/domainModel.png)
### 기본 문법과 쿼리 API
JPQL도 SQL과 비슷하게 SELECT, UPDATE, DELETE 문을 사용할 수 있다.  
참고로 엔티티를 저장할 때는 EntityManager.persist() 메소드를 사용하면 되므로 **INSERT문은 없다**.  
#### SELECT 문
- 대소문자 구분
  - **엔티티와 속성은 대소문자를 구분**한다.
  - 예를들어 Member, username 은 대소문자를 구분한다.
  - 반면, SELECT, FROM, AS 같은 **JPQL키워드는 대소문자를 구분하지 않는다.**
- 엔티티 이름
  - JPQL에서 사용한 Member 는 클래스 명이 아니라 엔티티 명이다.
  - 엔티티 명은 `@Entity(name = "XXX")`로 지정할 수 있다.
  - **엔티티 명을 지정하지 않으면 클래스 명을 기본값으로 사용**한다.
  - **기본값인 클래스 명을 엔티티 명으로 사용하는 것을 추천**한다.
- 별칭은 필수
  - Member AS m 을 보면 Member 에 m 이라는 별칭을 주었다.
  - **JPQL은 별칭을 필수로 사용**해야 한다!!
  - 따라서 다음 코드처럼 별칭 없이 작성하면 잘못된 문법이라는 오류가 발생한다.
  - `SELECT username FROM Member m`
#### TypeQuery, Query
**작성한 JPQL을 실행하려면 쿼리 객체를 만들어야 한다.**  
쿼리 객체는 TypeQuery와 Query가 있는데 **반환할 타입을 명확하게 지정할 수 있으면 TypeQuery 객체를 사용하고, 명확하게 지정할 수 없으면 Query 객체를 사용**하면 된다.  
```
TypeQuery<Member> query = 
    em.createQuery("SELECT m FROM Member m", Member.class);
```
**em.createQuery()의 두 번째 파라미터에 반환할 타입을 지정하면 TypeQuery를 반환하고 지정하지 않으면 Query를 반환**한다.  
```
Query query = 
    em.createQuery("SELECT m.username, m.age from Member m");
```
위의 경우 조회 대상이 String 타입인 회원 이름과 Integer 타입인 나이이므로 조회 대상 타입이 명확하지 않다.  
이처럼 **SELECT 절에서 여러 엔티티나 컬럼을 선택할 때**는 반환할 타입이 명확하지 않으므로 **Query 객체를 사용**해야 한다.  
**Query 객체는 SELECT 절의 조회 대상이 예제처럼 둘 이상이면 Object[ ]를 반환**하고, SELECT절의 **조회 대상이 하나면 Object를 반환**한다.  
예를 들어 `SELECT m.username from Member m` 이면 결과를 Object 로 반환하고, `SELECT m.username, m.age from Member m`이면 Object[ ]를 반환한다.  
두 코드를 비교해보면 타입을 반환할 필요가 없는 TypeQuery를 사용하는 것이 더 편리한 것을 알 수 있다.  

#### 결과 조회
다음 메소드들을 호출하면 실제 쿼리를 실행해서 데이터베이스를 조회한다.  
- query.getResultList( ): 결과를 예제로 반환한다. 만약 결과가 없으면 빈 컬렉션을 반환한다.
- query.getSingleResult(): 결과가 정확히 하나일 때 사용한다.
  - **결과가 없으면 NoResultException 예외가 발생**한다.
  - **결과가 1개보다 많으면 NoUniqueResultException 예외가 발생**한다.

### 파라미터 바인딩
JDBC는 위치 기준 파라미터 바인딩만 지원하지만, **JPQL은 이름 기준 파라미터 바인딩도 지원**한다.  
- 이름 기준 파라미터
  - 파라미터를 이름으로 구분하는 방법이다.
  - 이름 기준 파라미터는 앞에 :를 사용한다.
  - ```
    String usernameParam = "User1";
    
    TypedQuery<Member> query =
      em.createQuery("SELECT m FROM Member m WHERE m.username = :username", Member.class);
    
    query.setParameter("username", usernameParam);
    List<Member> resultList = query.getResultList();
    ```
  - 참고로 **JPQL API는 대부분 메소드 체인 방식으로 설계**되어 있어서 다음과 같이 연속해서 작성할 수 있다.
  - ```
    List<Member> members = 
      em.createQuery("SELECT m From Member m WHERE m.username = :username", Member.class)
        .setParameter("username", usernameParam)
        .getResultList();
    ```
  - 위치 기준 파라미터 방식보다는 **이름 기준 파라미터 바인딩 방식을 사용하는 것이 더 명확**하다.

### 프로젝션
**SELECT 절에 조회할 대상을 지정하는 것을 프로젝션** 이라 하고 `SELECT (프로젝션 대상) FROM` 으로 대상을 선택한다.  
프로젝션 대상은 엔티티, 엠비디드 타입, 스칼라 타입이 있다.  
- 엔티티 프로젝션
  - ```
    SELECT m FROM Member m //회원
    SELECT m.team FROM Member m //팀
    ```
  - 원하는 객체를 바로 조회한 것인데 컬럼을 하나하나 나열해서 조회해야 하는 SQL과는 차이가 있다.
  - 이렇게 **조회한 엔티티는 영속성 컨텍스트에서 관리**된다.
- 임베디드 타입 프로젝션
  - JPQL에서 이베디드 타입은 엔티티와 거의 비슷하게 사용된다.
  - 임베디드 타입은 조회의 시작점이 될 수 없다는 제약이 있다.
  - 다음은 임베디드 타입인 Address 를 조회의 시작점으로 사용해서 잘못된 쿼리이다.
  - ```
    String query = "SELECT a FROM Address a";
    ```
  - 다음 코드에서 Order 엔티티가 시작점이다.
  - ```
    String query = "SELECT o.address FROM Order o";
    List<Address> addresses = em.createQuery(query, Address.class)
                                .getResultList();
    ```  
  - **임베디드 타입은** 엔티티 타입이 아닌 **값 타입**이다.
  - **따라서 직접 조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않는다.**

> **임베디드 타입이란?**
>> 새로운 값 타입을 직접 정의해서 사용할 수 있는데, JPA에서는 이것을 임베디드 타입(embedded type)이라 합니다.  
>> 중요한 것은 직접 정의한 임베디드 타입도 `int`, `String` 처럼 값 타입이라는 것입니다.  
> ```
> //임베디드 타입을 사용하지 않았을 때
> @Entity
> public class Member {
> 
>   @Id @Generatedvalue
>   private Long id;
>   private String name;
> 
>   //근무 기간
>   @Temporal(TemporalType.DATE)
>   Date startDate;
>   @Temporal(TemporalType.DATE)
>   Date endDate;
> 
>   //집 주소 표현
>   private String city;
>   private String street;
>   private String zipcode;
> }
> ```
> ```
> //임베디드 타입 사용
> @Entity
> public class Member {
>
>   @Id @GeneratedVAlue
>   private Long id;
>   private String name;
>
>   @Embedded
>   private Period workPeriod;	// 근무 기간
>
>   @Embedded
>   private Address homeAddress;	// 집 주소
> }
> 
> //기간 임베디드 타입
> @Embeddable
> public class Peroid {
>
>   @Temporal(TemporalType.DATE)
>   Date startDate;
>   @Temporal(TemporalType/Date)
>   Date endDate;
>   // ...
>
>   public boolean isWork (Date date) {
>     // .. 값 타입을 위한 메서드를 정의할 수 있다
>   }
> }
> 
> //주소 임베디드 타입
> @Embeddable
> public class Address {
>
>     @Column(name="city") // 매핑할 컬럼 정의 가능
>     private String city;
>     private String street;
>     private String zipcode;
>     // ...
> }
> ```  

- 스칼라 타입 프로젝션
  - 숫자, 문자, 날짜와 같은 **기본 데이터 타입들을 스칼라 타입**이라 한다.
  - 예를 들어 전체 회원의 이름을 조회하려면 다음처럼 쿼리하면 된다.
  - ```
    List<String> usernames = 
      em.createQuert("SELECT username FROM Member m", String.class)
        .getResultList();
    ```
  - 다음과 같은 통계 쿼리도 주로 스칼라 타입으로 조회한다. (통계 쿼리용 함수들은 뒤에서 설명)
    - ```
      Double orderAmountAvg = 
        em.createQuert("SELECT AVG(o.orderAmount) FROM Order o", Double.class)
          .getSingleResult();
      ```  
- 여러 값 조회
  - 엔티티를 대상으로 조회하면 편리하겠지만, 꼭 필요한 데이터들만 선택해서 조회해야 할 때도 있다.
  - 프로젝션에 여러 값을 선택하면 TypeQuery를 사용할 수 없고 대신에 Query를 사용해야 한다.
  - ```
    Query query = 
      em.createQuery("SELECT m.username, m.age FROM Member m");
    List<Object[]> resultList = query.getResultList();
    
    Iterator iterator = resultList.iterator();
    while (iterator.hasNext()) {
      Object[] row = (Object[]) iterator.next();
      String username = (String) row[0];
      Integer age = (Integer) row[1];
    }
    ```
  - ```
    List<Object[]> resultList = 
      em.createQuery("SELECT m.username, m.age FROM Member m")
        .getResultList();
    
    for (Object[] row : resultList) {
      String username = (String) row[0];
      Integer age = (Integer) row[1];
    }
    ```  
  - 스칼라 타입 뿐만 아니라 엔티티 타입도 여러 값을 함께 조회할 수 있다.
  - ```
    List<Object[]> resultList = 
      em.createQuery("SELECT o.member, o.product, o.orderAmount FROM Order o")
        .getResultList();
    
    for (Object[] row : resultList) {
      Member memeber = (Member) row[0];       //엔티티
      Product product = (Product) row[1];     //엔티티
      Integer orderAmount = (Integer) row[2]; //스칼라
    }
    ```  
  - 물론 이 때 조회한 엔티티는 영속성 컨텍스트에서 관리된다.
- NEW 명령어
  - 실제 애플리케이션 개발시에는 Object[] 를 직접 사용하지 않고, UserDTO 처럼 의미 있는 객체로 변환해서 사용할 것이다.
  - ```
    List<Object[]> resultList = 
      em.createQuery("SELECT m.username, m.age FROM Member m")
        .getResultList();
    
    //객체 변환 작업
    List<UserDTO> userDTOs = new ArrayList<UserDTO>();
    for (Object[] row : resultList) {
      UserDTO userDTO = new UserDTO((String) row[0], (Integer) row[1]);
      userDTOs.add(userDTO);
    }
    ```
  - 이런 객체 변환 작업은 지루하다. NEW 명령어를 사용해보자
  - ```
    TypedQuery<UserDTO> query =
      em.createQuery("SELECT new jpabook.jpql.UserDTO(m.username, m.age)
      FROM Member m", UserDTO.class);
    
    List<UserDTO> resultList = query.getResultList();
    ```  
  - **SELECT 다음에 NEW 명령어를 사용하면 반환받을 클래스를 지정**할 수 있는데, 이 **클래스의 생성자에 JPQL 조회 결과를 넘겨줄 수 있다.**
  - 그리고 **NEW 명령어를 사용한 클래스로 TypeQuery를 사용할 수 있어** 지루한 **객체 변환 작업을 줄일 수 있다.**
  - 주의점 2가지
    1. **패키지 명을 포함한 전체 클래스 명을 입력**해야한다.
    2. **순서와 타입이 일치하는 생성자가 필요**하다.